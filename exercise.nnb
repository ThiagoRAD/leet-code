{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nConsider the number of unique elements in nums to be k​​​​​​​​​​​​​​. After removing duplicates, return the number of unique elements k.\n\nThe first k elements of nums should contain the unique numbers in sorted order. The remaining elements beyond index k - 1 can be ignored.\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\n```\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n```\nIf all assertions pass, then your solution will be accepted."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "var removeDuplicates = function(nums) {\n    for(let i = 1; i < nums.length; i++) {\n        if(nums[i-1] === nums[i]) {\n            nums.splice(i--, 1)\n        } \n    }\n    return nums.length\n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock.\n\nFind and return the maximum profit you can achieve.\n\n \n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n \n\nConstraints:\n\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    const points = []\n    let isBuying = true // starts without any token\n    let minmax = {}\n    let profit = 0\n    for(let i = 0; i < prices.length; i++) {\n        if(isBuying) {\n            let currentPrice = prices[i]\n            let nextPrice = prices[i+1]\n            if(nextPrice > currentPrice) { // it is better to buy now\n                minmax.min = currentPrice\n                isBuying = false\n                console.log(\"I am buying\", currentPrice)\n            }\n        } \n        if(!isBuying) {\n            let currentPrice = prices[i]\n            let nextPrice = prices[i+1]\n            if(nextPrice < currentPrice) { // it is better to sell now\n                minmax.max = currentPrice\n                isBuying = true\n                console.log(\"I am selling\", currentPrice)\n                profit -= minmax.min\n                profit += minmax.max\n            }\n        }\n    }\n    if(!isBuying) {\n        console.log(\"I am selling the last one\")\n        profit -= minmax.min\n        profit += prices[prices.length - 1]\n    }\n    return profit\n\n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105\n "
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function(nums, k) {\n    k = k % nums.length\n    const part = nums.splice(0, nums.length - k)\n    nums.push(...part)\n    \n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1]\n\nOutput: true\n\nExplanation:\n\nThe element 1 occurs at the indices 0 and 3.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\n\nOutput: false\n\nExplanation:\n\nAll elements are distinct.\n\nExample 3:\n\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\n\nOutput: true\n\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar containsDuplicate = function(nums) {\n    const occurrences = {}\n    for(const num of nums) {\n        if(occurrences[num]) return true\n        occurrences[num] = true\n    }\n    return false\n    \n};"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n \n\nExample 1:\n\nInput: nums = [2,2,1]\n\nOutput: 1\n\nExample 2:\n\nInput: nums = [4,1,2,1,2]\n\nOutput: 4\n\nExample 3:\n\nInput: nums = [1]\n\nOutput: 1\n\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\nEach element in the array appears twice except for one element which appears only once."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    const occurrences = {}\n    nums.forEach(num => {\n        if(occurrences[num]) {\n            delete occurrences[num]\n        } else {\n            occurrences[num] = true\n        }\n    })\n    return +Object.keys(occurrences)[0]\n    \n};"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\n\n \n\nExample 1:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\nExample 2:\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\nExplanation: [9,4] is also accepted.\n \n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 1000\n \n\nFollow up:\n\nWhat if the given array is already sorted? How would you optimize your algorithm?\nWhat if nums1's size is small compared to nums2's size? Which algorithm is better?\nWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersect = function(nums1, nums2) {\n    const nums1Values = {}\n    const nums2Values = {}\n    const answer = []\n    nums1.forEach(num => {\n        if(nums1Values[num]) {\n            nums1Values[num]++\n        } else {\n            nums1Values[num] = 1\n        }\n    })\n    nums2.forEach(num => {\n        if(nums2Values[num]) {\n            nums2Values[num]++\n        } else {\n            nums2Values[num] = 1\n        }\n    })\n    \n    for(const key in nums1Values) {\n        const occurrencesInNums1 = nums1Values[key]\n        const occurrencesInNums2 = nums2Values[key]\n        if(occurrencesInNums2) {\n            const minimalNumber = Math.min(occurrencesInNums1, occurrencesInNums2)\n            for(let i = 0; i < minimalNumber; i++) {\n                answer.push(+key)\n            }\n            \n        }\n    }\n    return answer\n};"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                ""
            ],
            "outputs": []
        }
    ]
}