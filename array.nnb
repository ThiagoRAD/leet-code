{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nConsider the number of unique elements in nums to be k​​​​​​​​​​​​​​. After removing duplicates, return the number of unique elements k.\n\nThe first k elements of nums should contain the unique numbers in sorted order. The remaining elements beyond index k - 1 can be ignored.\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\n```\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n```\nIf all assertions pass, then your solution will be accepted."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "var removeDuplicates = function(nums) {\n    for(let i = 1; i < nums.length; i++) {\n        if(nums[i-1] === nums[i]) {\n            nums.splice(i--, 1)\n        } \n    }\n    return nums.length\n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock.\n\nFind and return the maximum profit you can achieve.\n\n \n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n \n\nConstraints:\n\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    const points = []\n    let isBuying = true // starts without any token\n    let minmax = {}\n    let profit = 0\n    for(let i = 0; i < prices.length; i++) {\n        if(isBuying) {\n            let currentPrice = prices[i]\n            let nextPrice = prices[i+1]\n            if(nextPrice > currentPrice) { // it is better to buy now\n                minmax.min = currentPrice\n                isBuying = false\n                console.log(\"I am buying\", currentPrice)\n            }\n        } \n        if(!isBuying) {\n            let currentPrice = prices[i]\n            let nextPrice = prices[i+1]\n            if(nextPrice < currentPrice) { // it is better to sell now\n                minmax.max = currentPrice\n                isBuying = true\n                console.log(\"I am selling\", currentPrice)\n                profit -= minmax.min\n                profit += minmax.max\n            }\n        }\n    }\n    if(!isBuying) {\n        console.log(\"I am selling the last one\")\n        profit -= minmax.min\n        profit += prices[prices.length - 1]\n    }\n    return profit\n\n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105\n "
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function(nums, k) {\n    k = k % nums.length\n    const part = nums.splice(0, nums.length - k)\n    nums.push(...part)\n    \n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1]\n\nOutput: true\n\nExplanation:\n\nThe element 1 occurs at the indices 0 and 3.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\n\nOutput: false\n\nExplanation:\n\nAll elements are distinct.\n\nExample 3:\n\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\n\nOutput: true\n\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar containsDuplicate = function(nums) {\n    const occurrences = {}\n    for(const num of nums) {\n        if(occurrences[num]) return true\n        occurrences[num] = true\n    }\n    return false\n    \n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n \n\nExample 1:\n\nInput: nums = [2,2,1]\n\nOutput: 1\n\nExample 2:\n\nInput: nums = [4,1,2,1,2]\n\nOutput: 4\n\nExample 3:\n\nInput: nums = [1]\n\nOutput: 1\n\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\nEach element in the array appears twice except for one element which appears only once."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    const occurrences = {}\n    nums.forEach(num => {\n        if(occurrences[num]) {\n            delete occurrences[num]\n        } else {\n            occurrences[num] = true\n        }\n    })\n    return +Object.keys(occurrences)[0]\n    \n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\n\n \n\nExample 1:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\nExample 2:\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\nExplanation: [9,4] is also accepted.\n \n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 1000\n \n\nFollow up:\n\nWhat if the given array is already sorted? How would you optimize your algorithm?\nWhat if nums1's size is small compared to nums2's size? Which algorithm is better?\nWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersect = function(nums1, nums2) {\n    const nums1Values = {}\n    const nums2Values = {}\n    const answer = []\n    nums1.forEach(num => {\n        if(nums1Values[num]) {\n            nums1Values[num]++\n        } else {\n            nums1Values[num] = 1\n        }\n    })\n    nums2.forEach(num => {\n        if(nums2Values[num]) {\n            nums2Values[num]++\n        } else {\n            nums2Values[num] = 1\n        }\n    })\n    \n    for(const key in nums1Values) {\n        const occurrencesInNums1 = nums1Values[key]\n        const occurrencesInNums2 = nums2Values[key]\n        if(occurrencesInNums2) {\n            const minimalNumber = Math.min(occurrencesInNums1, occurrencesInNums2)\n            for(let i = 0; i < minimalNumber; i++) {\n                answer.push(+key)\n            }\n            \n        }\n    }\n    return answer\n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n\nIncrement the large integer by one and return the resulting array of digits.\n\n \n\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n \n\nConstraints:\n\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function(digits) {\n    for(let i = digits.length - 1; i >= 0; i--) {\n        if(digits[i] == 9) {\n            digits[i] = 0\n        } else {\n            digits[i]++\n            return digits\n        }\n    }\n    if(digits[0] == 0) digits.unshift(1)\n    return digits\n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.\n\n \n\nExample 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\n\nInput: nums = [0]\nOutput: [0]\n \n\nConstraints:\n\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\n \n\nFollow up: Could you minimize the total number of operations done?"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function(nums) {\n    for(let i = nums.length - 1; i >= 0; i--) {\n        if(nums[i] == 0) {\n            nums.splice(i, 1)\n            nums.push(0)\n        }\n    }\n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n \n\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    for(let i=0; i<nums.length; i++) {\n        for(let j = 1; j<nums.length;j++) {\n            if(i == j) continue\n            if(nums[i]+nums[j] == target) return [i,j]\n        }\n    }\n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\nEach row must contain the digits 1-9 without repetition.\nEach column must contain the digits 1-9 without repetition.\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\nNote:\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\nOnly the filled cells need to be validated according to the mentioned rules.\n \n\nExample 1:\n\n\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\nExample 2:\n\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n \n\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit 1-9 or '.'."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function(board) {\n    for(let i = 0; i < 9; i++) {\n        const rowElements = {}\n        const colElements = {}\n        for(let j = 0; j < 9; j++) {\n            const rowValue = board[i][j]\n            const colValue = board[j][i]\n            if(rowElements[rowValue]) return false\n            if(colElements[colValue]) return false\n            if(rowValue != '.') rowElements[rowValue] = true\n            if(colValue != '.') colElements[colValue] = true\n            \n        }\n        console.log(JSON.stringify(rowElements))\n        console.log(JSON.stringify(colElements))\n    }\n    for(let i = 1; i <= 7; i+=3) {\n        for(let j = 1; j <= 7; j+=3) {\n            const result = checkAround(board, i, j)\n            if(!result) return false\n        }\n    }\n    return true\n    \n};\n\nconst checkAround = (board, x, y) => {\n    const elements = {}\n    for(let i = -1; i <= 1; i++) {\n        for(let j = -1; j <= 1; j++) {\n            const value = board[x+i][y+j]\n            if(elements[value]) return false\n            if(value != '.') elements[value] = true\n        }\n    }\n    return true\n}"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n \n\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\nExample 2:\n\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n \n\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function(matrix) {\n    const size = matrix.length\n    for(let i = 0; i < size; i++) {\n        for(let j = i; j < size; j++) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]\n        }\n    }\n    for(let i = 0; i < size; i++) {\n        matrix[i].reverse()\n    }\n    \n};"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}